{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf330
{\fonttbl\f0\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Creating a Decoder Plugin for Eavesdrop\
\
1) Create a new project using the template for a Bundle\
\
2) Add in the PacketHandler.framework from the dev kit\
\
3) In your source file, import Packet.h from the framework\
\
4) Your new decoder should inherit from Packet, which implements the protocol <PacketHandler> for you.  Taking a look at the header file will tell you what methods are necessary, but effectively, this is the bare minimum of what you need to implement:\
\
@interface MyPacket : Packet \{\
\
\}\
\
+ (NSDictionary *)keyNames;\
- (BOOL)canDecodePacketData:(NSData *)packetToDecode;\
\
@end\
\
The class method keyNames should return a dictionary of name/value pairs where the name is the method (or key) that you implement to return some property of the packet and a value of the human readable key name.\
\
Of course, without anything more this subclass is mostly pointless.  To be useful, some keys should be implemented that will analyze the packet data and return something meaningful.  Since decoders work with inheritance, you get all the properties from parent class automatically.  For example, if you wanted to have a protocol that ran on top of HTTP, then you could start with the supplied TCPPacket class and inherit from that.  (I plan to supply a framework for each of the plugins that I write so there will be a consistent jumping off point for others.)  You may end up with classes that have an inheritance chain that looks like:\
\
Packet -> EthernetPacket -> IPPacket -> TCPPacket -> HTTPPacket -> MyPacket\
\
Each layer will provide it's own keys and values (which can be summarized by the - detail method of Packet) and expand on it's parents.\
\
5) The final step is to provide a plist that will tell the plugin controller what protocol you will be implementing.  (Note: this process is not tolerant to name conflicts, the last plugin to load will be the only one loaded - even if the actual code was not related, load order is not gaurenteed.)\
\
The plist must be an array of dictionaries.  Each dictionary must have a key "class" and a key "protocol".\
\
Creating an Aggregator Plugin for Eavesdrop}